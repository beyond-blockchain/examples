Certify Web
==========
This app provides very simple Web API sample to provide functionality equivalent to "certificates" example, plus a very simple sample Web application to use the API. Together, this example provides the full functionality of "certificates" including "certificates.py", "cert_flask.py", and "certificate_tool.py".

The following set of API is provided:
* **/api/register** [POST] registers a single document to BBc-1 and the ledger subsystem.
* **/api/proof** [GET] provides the Merkle proof for a registered document, using which a certificate can be built.
* **/api/verify** [GET] verifies the content of the certificate and the registration date & time.
* **/api/setup** [POST] sets the environment (a BBc-1 domain and a simple database).

In addition, the following set of API is provided for learning purposes (should not really be provided over the network):
* **/api/digest** [GET] gives SHA-256 digest of a given JSON (sub-)document.
* **/api/keypair** [GET] generates a ECDSA p256v1 key pair.
* **/api/sign** [GET] signs and returns the signature, the algorithm and the public key for a given JSON (sub-)document and a private key.

The sample Web application lets a user to try out all of the above, plus registration of multiple documents at once, and building a certificate out of the original document and its Merkle proof, which the user can download.

## Dependencies
* bbc1 >= 1.5
* py-bbclib >= 1.6
* bbc1-lib-std >= 0.19
* bbc1-lib-registry >= 0.8
* ledger_subsystem >= 0.15
* Flask >= 1.1.2

## Installing dependencies
You need to pip-install bbc1 and Flask. Others (BBc-1 libraries bbc1-lib-?? and ledger_subsystem) are currently at their late development stages, and you will need to do `git clone -b develop [URI]`  to clone the project's development branch, go to the project directory and `python setup.py sdist` to generate an installer tar ball, and then `pip install dist/[tar.gz file]`.

* For further information on installing and using bbc1, see [tutorials](https://github.com/beyond-blockchain/bbc1/tree/develop/docs)
* Those tutorials are in Japanese for the time being.

## Documents and Certificates
A document or a certificate (which is a document with Merkle proof information) in this examlpe is a JSON text, but translated into XML at the server side because that is the format used in bbc1-lib-registry (see Flask execution log for the effect). An example of a document follows.
```
{
  "id": "AR-1838B",
  "title": "I Am the Walrus",
  "artist": "The Beatles",
  "writer": "Lennon-McCartney",
  "year": "1967"
}
```
To get the cryptographic digest of a document (for proof), this example takes each key-value pair as an XML element (```<id/>```, ```<title/>```, ```<artist/>```, ```<writer/>```,```<year/>``` for the above), calculate their SHA-256 digests, concatinate them all, and then calculate its SHA-256 digest. If a value is a dictionary, this algorithm is applied recursively.

You can specify multiple documents at once with the app for registration by specifying them with an array with key "_docs". Please see "beatles-singles-doc.json" sample document file accompanied with this example.

There are keys that give special meanings to their value:
* **id** Number or string that identifies the document.
* **digest** (in fact any key starting with 'digest', to make keys unique) SHA-256 digest of a hidden element (functionality of bbc1-lib-registry). Upon calculating the cryprographic digest of the document or certificate, the value is considered as the hexadecimal representation of the digest of the key-value pair at the position. You can use the provided app to obtain the SHA-256 digest of any JSON (sub-)document.
* **proof** (reserved for this purpose and generated by /api/proof) Merkle proof information for the document. Please see "i-am-the-walrus-cert.json" sample certificate.
* **privkey** Private key (used only when signing the document with it).
* **pubkey** Public key to verify a signature.
* **sig** Digital signature. Needs to be accompanied by **pubkey**. If this key is present, the cryptographic digest of the document (or part of the document, depending on where this key appears) is considered signed, the signature is verified, and the new digest is calculated over concatination of the digest, the public key, the 2-byte key-type code (see bbclib.KeyType) and the signature. Please see "ishindenshin-cert.json" sample certificate.
* **algo** Digital signature algorithm in use. Currently supports ECDSA_SECP256k1 (ecdsa-secp256k1) and ECDSA_P256v1 (ecdsa-p256v1). ECDSA p256v1 is the default.
* **salt** If this key is present and the value is a dictionary, the key-value pairs in the dictionary are considered to specify salts for the keys to calculate digests, if those keys are found at the same level as this key.

## How to use this example
Below, it is assumed that "bbc_core.py" runs at the user's home directory, and Ethereum's ropsten testnet is used (and you have a sufficient amount of ETH (1 would be more than enough) in an account in ropsten). At first, "bbc_core.py" should be stopped.

1. Set up ledger subsystem (this writes to BBc-1 core's config file)
    ```
    eth_subsystem_tool.py -w ~/.bbc1 auto [infura.io project ID] [private key]
    ```
    Take note (make copy) of the displayed contract address that was deployed by the command above.

2. Start bbc_core.py

3. Set up the API

    POST 'api/setup' to set up.
    ```shell
    $ curl -X POST http://IP_ADDRESS:PORT/api/setup
    {"domain_id": DOMAIN_ID} # returned
    ```

4. Stop bbc_core.py (because again we will write to BBc-1 core's config file)

5. Configure Merkle tree settings of the ledger subsystem

    ```
    eth_subsystem_tool.py -w ~/.bbc1 -d [domain id] config_tree [number of certificates] [seconds]
    ```
        
    This configures the subsystem so that Merkle tree is closed and Merkle root is written to a Ethereum blockchain (ropsten by default) upon reaching either the specified number of processed documents or the specified seconds.

6. Start bbc_core.py

7. Start index.py of this example

    By default, the server runs at "http://localhost:5000/cert". You can paste your JSON document onto the text area, or open an existing JSON file for processing.

**certify_tool.py** is a utility program to print the query string for a certificate that is compatible with "certificates" example.
